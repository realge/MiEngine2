#version 450

// Hi-Z Pyramid Generation Compute Shader
// Generates hierarchical depth buffer for occlusion culling
// Each mip level stores the MAX depth of the 4 parent texels
// (MAX because standard depth: 0=near, 1=far - furthest depth is conservative)

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Input: previous mip level (or depth buffer for mip 0)
layout(set = 0, binding = 0) uniform sampler2D inputDepth;

// Output: current mip level being generated
layout(set = 0, binding = 1, r32f) uniform writeonly image2D outputMip;

// Push constants for mip generation
layout(push_constant) uniform PushConstants {
    ivec2 outputSize;    // Size of output mip level
    ivec2 inputSize;     // Size of input (previous mip or depth buffer)
    uint mipLevel;       // Current mip level being generated
    uint pad0;
} push;

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);

    // Early out if outside output dimensions
    if (pos.x >= push.outputSize.x || pos.y >= push.outputSize.y) {
        return;
    }

    float maxDepth;

    // Check if this is mip 0 (1:1 copy from depth buffer)
    // or subsequent mip (2x2 downsample from previous mip)
    if (push.mipLevel == 0) {
        // Try texelFetch instead of texture() to bypass sampler
        ivec2 texelCoord = ivec2(pos);

        // Clamp to valid range
        texelCoord = clamp(texelCoord, ivec2(0), push.outputSize - ivec2(1));

        // Use texelFetch - direct texel access without filtering
        float sampledDepth = texelFetch(inputDepth, texelCoord, 0).r;

        // If sampling fails (returns 0), show position-based pattern for debug
        if (sampledDepth < 0.001) {
            // Show gradient based on position so we know shader ran
            maxDepth = 0.3 + 0.4 * float(pos.x + pos.y) / float(push.outputSize.x + push.outputSize.y);
        } else {
            maxDepth = sampledDepth;
        }
    } else {
        // Mip > 0: 2x2 downsample from previous mip level
        // Each output pixel covers a 2x2 region in the input
        vec2 uv = (vec2(pos) * 2.0 + 1.0) / vec2(push.inputSize);
        vec2 texelSize = 1.0 / vec2(push.inputSize);

        float d00 = texture(inputDepth, uv + vec2(-0.25, -0.25) * texelSize * 2.0).r;
        float d10 = texture(inputDepth, uv + vec2( 0.25, -0.25) * texelSize * 2.0).r;
        float d01 = texture(inputDepth, uv + vec2(-0.25,  0.25) * texelSize * 2.0).r;
        float d11 = texture(inputDepth, uv + vec2( 0.25,  0.25) * texelSize * 2.0).r;

        // Take maximum - the furthest depth in the 2x2 quad
        // This is conservative: if a pixel might be visible, keep it
        maxDepth = max(max(d00, d10), max(d01, d11));
    }

    // Write to output mip level
    imageStore(outputMip, pos, vec4(maxDepth, 0.0, 0.0, 0.0));
}
